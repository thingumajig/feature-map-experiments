import io
import base64
import json
import asyncio
import traceback

from pathlib import Path
from nicegui import app, ui
from fastapi import FastAPI, HTTPException, Response
from numpy import row_stack
from starlette.responses import StreamingResponse
from PIL import Image

from PIL import Image

from nicegui.events import MouseEventArguments, GenericEventArguments
import yaml

from fmc.patches_utils import combine_patches


n_cols = 8
n_rows = 5
patch_size = 224

white_patch = Image.new('RGB', (patch_size, patch_size), color=(241, 241, 249))   #(255, 255, 255))

viewport_width = 1600
viewport_height = 1000

# num_patches_x = width // patch_size
# num_patches_y = height // patch_size

method_patch_size = 256

image_index_root = Path(__file__).parent / '.indexes'

methods = ['pca', 
        #    'umap', 'kmeans-pca', 'kmeans-umap', 'hdbscan'
           ]



@app.get('/p/{x}/{y}/{magnification}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_patch(x: int, y: int, magnification: int):
    try:
        # image_data = get_current_image()
        image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
        # print(f'get patch from original image: {x} {y}')
        orig_image_path = image_index_root / image_key / 'original' / f'{x}_{y}.png'
        # print(f'{orig_image_path.exists()=}')
        if magnification > 1: 
            patch = combine_patches(image_index_root, image_key, 'original', (x, y), magnification, (patch_size, patch_size))
            buff = io.BytesIO()
            patch.save(buff, format='PNG')
            buff.seek(0)
            #TODO: save image to disk for caching
        else:
            if orig_image_path.exists():
                # patch = image_data.image.crop((x, y, x + patch_size, y + patch_size))
                # patch = Image.open(orig_image_path).convert('RGB')

                with orig_image_path.open('rb') as f:
                    buff = io.BytesIO()
                    buff.write(f.read())
                    buff.seek(0)
            else:
                patch = white_patch
                buff = io.BytesIO()
                patch.save(buff, format='PNG')
                buff.seek(0)

        # print(f'load original image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=604800'}
                                 )
    except Exception as e:
        print(f'File "original/{x}_{y}": {e}')
        traceback.print_exc(limit=2)
        raise HTTPException(status_code=400, detail=str(e))
    

@app.get('/x/{method}/{x}/{y}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_processed_patch(method: str, x: int, y: int):
    try:
        image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
        # print(f'get pca patch from original image: {x} {y}')
        # x = (x // patch_size) * method_patch_size
        # y = (y // patch_size) * method_patch_size
        # print(f'{x=} {y=}')

        method_image_path = image_index_root / image_key / method / f'{x}_{y}.png'
        # print(f'{method_image_path.exists()=}')

        if method_image_path.exists():
            with method_image_path.open('rb') as f:
                buff = io.BytesIO()
                buff.write(f.read())
                buff.seek(0)
        else:
                patch = white_patch
                buff = io.BytesIO()
                patch.save(buff, format='PNG')
                buff.seek(0)
                        
        # patch = Image.open(method_image_path).convert('RGBA')
        # buff = io.BytesIO()
        # patch.save(buff, format='PNG')
        # buff.seek(0)
        
        
        # print(f'load pca image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=604800'}
                                 )
    except Exception as e:
        print(f'File "{image_key}/{method}/{x}_{y}": {e}')
        # traceback.print_exc()
        raise HTTPException(status_code=400, detail=str(e))


def load_patch_svg(x, y, origin_x, origin_y, magnification, patch_index_x, patch_index_y):

    # right = left + patch_size
    # bottom = top + patch_size
    # patch = large_image.crop((left, top, right, bottom))
    # patch_bytes = io.BytesIO()
    # patch.save(patch_bytes, format='PNG')
    # patch_bytes = patch_bytes.getvalue()
    # data_uri = 'data:image/png;base64,' + \
    #     base64.b64encode(patch_bytes).decode('utf-8')
    data_uri = f'/p/{patch_index_x}/{patch_index_y}/{magnification}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{x-origin_x}" y="{y-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" />'


def load_p_patch_svg(method, x, y, origin_x, origin_y):
    left = x
    top = y
    opacity = app.storage.user.get(f'{method}_opacity', 0.5)
    data_uri = f'/x/{method}/{x}/{y}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{left-origin_x}" y="{top-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" opacity="{opacity}"/>'

def get_svg(context, origin_x: int, origin_y: int, x2: int, y2: int, magnification: int=1):
    # print(f'svg from:{context} {origin_x=} {origin_y=} {x2=} {y2=}')
    # pca_flag = app.storage.user.get('draw_pca', False)
    # print(f'pca flag: {pca_flag}')
    w_patch_size = patch_size * magnification


    grid_aligned_origin_x = int(origin_x // w_patch_size) * w_patch_size
    grid_aligned_origin_y = int(origin_y // w_patch_size) * w_patch_size

    px_start = grid_aligned_origin_x
    py_start = grid_aligned_origin_y
    # if abs(grid_aligned_origin_x-origin_x) > patch_size:
    #     grid_aligned_origin_x += w_patch_size
    #     px_start += patch_size
    # if abs(grid_aligned_origin_y-origin_y) > patch_size:
    #     grid_aligned_origin_y += w_patch_size
    #     py_start += patch_size


    # deltax = origin_x - grid_aligned_origin_x
    # deltay = origin_y - grid_aligned_origin_y
    print(f'{grid_aligned_origin_x}-{origin_x}={grid_aligned_origin_x-origin_x} {grid_aligned_origin_y}-{origin_y}={grid_aligned_origin_y-origin_y}')

    svg = f'<svg width="{viewport_width}px" height="{viewport_height}px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'
    # svg = f'<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'

    patch_index_y = py_start
    for y in range(grid_aligned_origin_y, y2 + 1, patch_size):
        patch_index_x = px_start
        for x in range(grid_aligned_origin_x, x2 + 1, patch_size):
            svg += load_patch_svg(x, y, origin_x, origin_y, magnification, patch_index_x, patch_index_y)
            for m in methods:
                flag = app.storage.user.get(f'draw_{m}', False)
                if flag:
                    svg += load_p_patch_svg(m, x, y, origin_x, origin_y)

            patch_index_x += w_patch_size
        patch_index_y += w_patch_size


    svg += '</svg>'
    return svg


def update_user_view_state(mouse_down=True, pan_start=None, current_image_corner=None):
    app.storage.user['mouse_down'] = mouse_down
    if pan_start:
        app.storage.user['pan_start'] = pan_start
    if current_image_corner:
        app.storage.user['current_image_corner'] = current_image_corner
        image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
        app.storage.general[f'{image_key}_image_corner'] = current_image_corner


def mouse_handler(e: MouseEventArguments):
    # image_data = get_current_image()
    # width, height = (n_cols * patch_size, n_rows * patch_size)

    if e.type == 'mousedown':
        update_user_view_state(
            mouse_down=True, pan_start=(e.image_x, e.image_y))
    elif (app.storage.user['mouse_down'] and e.type == 'mousemove') or e.type == 'mouseup':
        # print(f"event: {e.type} {e.image_x} {app.storage.user['mouse_down']}")
        pan_start = app.storage.user['pan_start']

        delta_x = int(e.image_x - pan_start[0])
        delta_y = int(e.image_y - pan_start[1])

        x, y, magnification = app.storage.user.get('current_image_corner', (5000, 5000, 1))
        print(f'({delta_x=}, {delta_y=}) ({x=}, {y=}) new: ({x-delta_x},{y-delta_y})')

        x = max(x-delta_x, 0)
        y = max(y-delta_y, 0)

        # x = min(x, width-viewport_width)
        # y = min(y, height-viewport_height)

        update_user_view_state(
            mouse_down=(e.type == 'mousemove'), 
            pan_start=(e.image_x, e.image_y), 
            current_image_corner=(x, y, magnification)
            )
        e.sender.set_content(get_svg('mouse', x, y, x+viewport_width, y+viewport_height, magnification))
    elif e.type == 'mouseleave':
        update_user_view_state(mouse_down=False)
    elif e.type == 'wheel': 
        print(f'{e}')


def wheel_handler(e: GenericEventArguments):
    print(f"{e=}, {e.args['deltaY']=}")
    x, y, magnification = app.storage.user.get('current_image_corner', (5000, 5000, 1))
    if e.args['deltaY']<0:
        magnification = max(magnification-1, 1)
    elif e.args['deltaY']>0:
        magnification = min(magnification+1, 5)

    # print(f'{x=} {y=} {magnification=}')
    update_user_view_state(mouse_down=False, current_image_corner=(x, y, magnification))
    e.sender.set_content(get_svg('wheel', x, y, x+viewport_width, y+viewport_height, magnification))




def update_pca_draw(flag: bool, viewer):
    x, y, magnification = app.storage.user.get('current_image_corner', (0, 0, 1))
    viewer.set_content(get_svg('pca',x, y, x+viewport_width, y+viewport_height, magnification))

@ui.page('/')
async def main_page():
    # app.storage.client['image_data'] = None
    # await ui.context.client.connected()
    image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
    update_user_view_state(mouse_down=False, 
                           current_image_corner=app.storage.general.get(f'{image_key}_image_corner', (500, 500, 1))
                           )
    print(f"======== main page ({image_key=}, {app.storage.general.get(f'{image_key}_image_corner', (500, 500, 1))})")

    ui.add_head_html('''
        <style>
        body {
            overflow:hidden;
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        body::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        </style>
                     
        <style type="text/tailwindcss">
            p {
                font-size: 80%;
            }
            
            div {
                font-size: 100%;
            }
        </style>                     
    ''')

    ui.add_css('''
        :root {
            --nicegui-default-padding: 0.1rem;
            --nicegui-default-gap: 1rem;
        }
    ''')

    # with ui.card().tight() as container:
    # with ui.row().classes('w-full h-full no-wrap') as container:

        # container.style(
        #     'display: flex; flex-direction: column; width: 100%; height: 80%;  overflow: hidden;')

        # ui.label('Viewer')
    x, y, magnification = app.storage.user.get('current_image_corner', (500, 500, 1))
    viewer = ui.interactive_image(
        content=get_svg('initial',x, y, x+viewport_width, y+viewport_height, magnification), 
        size=(viewport_width, viewport_width),
        # size=('100%', '100%'),
        on_mouse=mouse_handler, events=[
            'mousedown', 'mousemove', 'mouseup', 'mouseleave', 'wheel'],
        cross=False
    ).classes('w-full h-dvh').props('fit=scale-down')
    # 
    # .classes('w-64 bg-blue-50')
    # .style('width: 100%; height: 100%; object-fit: cover;')

    # viewer.on('wheel', wheel_handler)
 
    with ui.header(elevated=True).style('background-color: #3874c8').classes('items-center justify-between'):
        ui.image('roseaid_logo_white.png').classes('w-32')
        ui.label('Cells Regions Of Interest')
        ui.button(on_click=lambda: right_drawer.toggle(),
                  icon='menu').props('flat color=white')
    # with ui.left_drawer(top_corner=True, bottom_corner=True).style('background-color: #d7e3f4'):
    #     ui.label('LEFT DRAWER')
    with ui.right_drawer(fixed=False).style('background-color: #ebf1fa').props('bordered') as right_drawer:

        with ui.expansion('Tasks', icon='precision_manufacturing', value=True).classes('w-full'):
            for m in methods:
                fm = ui.checkbox(f'Draw heatmap ({m})', on_change=lambda e: update_pca_draw(e.value, viewer)).bind_value(app.storage.user, f'draw_{m}')
                with ui.grid(columns='60px 90px').classes('w-full').bind_visibility_from(fm, 'value'):
                    ui.label('Opacity:')
                    slider = ui.slider(min=0., max=1., value=0.5, step=0.1, on_change=lambda e: update_pca_draw(
                        e.value, viewer)).bind_value(app.storage.user, f'{m}_opacity')
        with ui.expansion('WSI metadata', icon='settings', value=True).classes('w-full'):
            image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
            image_metadata_path = image_index_root / image_key / 'metadata.yaml'
            # columns = [
            # {'name': 'Name', 'label': 'Name', 'field': 'name', 'required': True, 'align': 'left'},
            # {'name': 'Value', 'label': 'Value', 'field': 'value', 'sortable': True},
            # ]

            rows = []
            if image_metadata_path.exists():
                with image_metadata_path.open('r') as f:
                    metadata = yaml.safe_load(f)

                    for k, v in metadata.items():
                        rows.append({'name': k, 'value': v})

            else:
                rows = []

            metadata_table = ui.aggrid({
                'defaultColDef': {'flex': 1},
                'columnDefs': [
                    {'headerName': 'Name', 'field': 'name', },
                    {'headerName': 'Value', 'field': 'value'},
                ],
                'rowData': rows,
                'rowSelection': 'multiple',
            }).style('height: 350px;')
            # .classes('max-h-40')

            # metadata_table =ui.table(columns=columns, rows=rows, row_key='name').classes('w-full text-sm/[16px]').props('virtual-scroll')
            # metadata_table.add_slot('body-cell-one', r'''
            #     <td :props="props" :class="(props.row.one == '') ? '' : 'bg-info'" style="text-align: center; width: 20px">
            #         <q-icon :name="priority_high" size="sm"/>
            #     </td>                                    
            #     ''')
          
                    
    with ui.footer().style('background-color: #3874c8; height: 40px;').classes('items-center justify-between'):
        ui.label('ok.').bind_text_from(app.storage.user,'current_image_corner', backward=lambda c: f'Pos: x={c[0]}, y={c[1]} magnification={c[2]}')



ui.run(
    host='0.0.0.0',
    port=8089,
    storage_secret='123',
    reload=True,
    )
