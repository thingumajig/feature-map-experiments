import io
import base64
import json
import asyncio
import traceback

from pathlib import Path
from nicegui import app, ui
from fastapi import FastAPI, HTTPException, Response
from starlette.responses import StreamingResponse
from PIL import Image

from PIL import Image

from nicegui.events import MouseEventArguments

n_cols = 8
n_rows = 5
patch_size = 224

white_patch = Image.new('RGB', (patch_size, patch_size), color=(255, 255, 255))

viewport_width = 1600
viewport_height = 1000

# num_patches_x = width // patch_size
# num_patches_y = height // patch_size

method_patch_size = 256

image_index_root = Path(__file__).parent / '.indexes'

methods = ['pca', 'umap', 'kmeans-pca', 'kmeans-umap', 'hdbscan']

@app.get('/p/{x}/{y}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_patch(x: int, y: int):
    try:
        # image_data = get_current_image()
        image_key = app.storage.user.get('image_key', 'C-17-036-2021-07-15_215134__ndpi')
        # print(f'get patch from original image: {x} {y}')
        orig_image_path = image_index_root / image_key / 'original' / f'{x}_{y}.png'
        # print(f'{orig_image_path.exists()=}')

        if orig_image_path.exists():
            # patch = image_data.image.crop((x, y, x + patch_size, y + patch_size))
            patch = Image.open(orig_image_path).convert('RGB')
        else:
            patch = white_patch

        buff = io.BytesIO()
        patch.save(buff, format='PNG')
        buff.seek(0)
        # print(f'load original image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=600'}
                                 )
    except Exception as e:
        print(f'File "original/{x}_{y}" not found?')
        raise HTTPException(status_code=400, detail=str(e))
    

@app.get('/x/{method}/{x}/{y}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_processed_patch(method: str, x: int, y: int):
    try:
        image_key = app.storage.user.get('image_key', 'c17-part1')
        # print(f'get pca patch from original image: {x} {y}')
        x = (x // patch_size) * method_patch_size
        y = (y // patch_size) * method_patch_size
        # print(f'{x=} {y=}')

        method_image_path = image_index_root / image_key / method / f'{x}_{y}.png'
        # print(f'{method_image_path.exists()=}')
        patch = Image.open(method_image_path).convert('RGBA')
        buff = io.BytesIO()
        patch.save(buff, format='PNG')
        buff.seek(0)
        # print(f'load pca image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=600'}
                                 )
    except Exception as e:
        print(f'File "{method}/{x}_{y}" not found?')
        # traceback.print_exc()
        raise HTTPException(status_code=400, detail=str(e))


def load_patch_svg(x, y, origin_x, origin_y):
    left = x
    top = y

    # right = left + patch_size
    # bottom = top + patch_size
    # patch = large_image.crop((left, top, right, bottom))
    # patch_bytes = io.BytesIO()
    # patch.save(patch_bytes, format='PNG')
    # patch_bytes = patch_bytes.getvalue()
    # data_uri = 'data:image/png;base64,' + \
    #     base64.b64encode(patch_bytes).decode('utf-8')

    data_uri = f'/p/{x}/{y}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{left-origin_x}" y="{top-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" />'


def load_p_patch_svg(method, x, y, origin_x, origin_y):
    left = x
    top = y
    opacity = app.storage.user.get(f'{method}_opacity', 0.5)
    data_uri = f'/x/{method}/{x}/{y}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{left-origin_x}" y="{top-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" opacity="{opacity}"/>'

def get_svg(x1: int, y1: int, x2: int, y2: int):
    # print(f'get svg: {x1=} {y1=} {x2=} {y2=}')
    # pca_flag = app.storage.user.get('draw_pca', False)
    # print(f'pca flag: {pca_flag}')

    gridx = int(x1 // patch_size) * patch_size
    gridy = int(y1 // patch_size) * patch_size

    deltax = x1 - gridx
    deltay = y1 - gridy
    # print(f'{gridx=} {gridy=} {deltax=} {deltay=}')

    svg = f'<svg width="{viewport_width}px" height="{viewport_height}px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'
    # svg = f'<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'

    for y in range(gridy, y2 + 1, patch_size):
        for x in range(gridx, x2 + 1, patch_size):
            svg += load_patch_svg(x, y, x1, y1)
            for m in methods:
                flag = app.storage.user.get(f'draw_{m}', False)
                if flag:
                    svg += load_p_patch_svg(m, x, y, x1, y1)

    svg += '</svg>'
    return svg

    
def get_user_view_state():
    return (
        app.storage.user.get('mouse_down', False),
        app.storage.user.get('pan_start', (0, 0)),
        app.storage.user.get('current_image_corner', (0, 0)),
    )


def update_user_view_state(mouse_down=True, pan_start=None, current_image_corner=None):
    app.storage.user['mouse_down'] = mouse_down
    if pan_start:
        app.storage.user['pan_start'] = pan_start
    if current_image_corner:
        app.storage.user['current_image_corner'] = current_image_corner


def mouse_handler(e: MouseEventArguments):
    # image_data = get_current_image()
    # width, height = (n_cols * patch_size, n_rows * patch_size)

    if e.type == 'mousedown':
        update_user_view_state(
            mouse_down=True, pan_start=(e.image_x, e.image_y))
    elif (app.storage.user['mouse_down'] and e.type == 'mousemove') or e.type == 'mouseup':
        # print(f"event: {e.type} {e.image_x} {app.storage.user['mouse_down']}")
        pan_start = app.storage.user['pan_start']

        delta_x = int(e.image_x - pan_start[0])
        delta_y = int(e.image_y - pan_start[1])

        x, y = app.storage.user.get('current_image_corner', (0, 0))

        x = max(x-delta_x, 0)
        y = max(y-delta_y, 0)

        # x = min(x, width-viewport_width)
        # y = min(y, height-viewport_height)

        # print(f'{e.type}: {delta_x=} {delta_y=} {x=} {y=}')
        update_user_view_state(mouse_down=(e.type == 'mousemove'), pan_start=(
            e.image_x, e.image_y), current_image_corner=(x, y))
        e.sender.set_content(
            get_svg(x, y, x+viewport_width, y+viewport_height))
    elif e.type == 'mouseleave':
        update_user_view_state(mouse_down=False)


def update_pca_draw(flag: bool, viewer):
    x, y = app.storage.user.get('current_image_corner', (0, 0))
    viewer.set_content(get_svg(x, y, x+viewport_width, y+viewport_height))

@ui.page('/')
async def main_page():
    # app.storage.client['image_data'] = None
    await ui.context.client.connected()
    
    ui.add_head_html('''
        <style>
        body {
            overflow:hidden;
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        body::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        </style>
    ''')

    # with ui.card().tight() as container:
    # with ui.row().classes('w-full h-full no-wrap') as container:

        # container.style(
        #     'display: flex; flex-direction: column; width: 100%; height: 80%;  overflow: hidden;')

        # ui.label('Viewer')
    update_user_view_state(mouse_down=False, current_image_corner=(0, 0))
    viewer = ui.interactive_image(
        content=get_svg(0, 0, viewport_width, viewport_height), 
        size=(viewport_width, viewport_width),
        # size=('100%', '100%'),
        on_mouse=mouse_handler, events=[
            'mousedown', 'mousemove', 'mouseup', 'mouseleave'],
        cross=False
    ).classes('w-full h-screen').props('fit=scale-down')
    # 
    # .classes('w-64 bg-blue-50')
    # .style('width: 100%; height: 100%; object-fit: cover;')


    with ui.header(elevated=True).style('background-color: #3874c8').classes('items-center justify-between'):
        ui.image('roseaid_logo_white.png').classes('w-32')
        ui.label('Cells Regions Of Interest')
        ui.button(on_click=lambda: right_drawer.toggle(),
                  icon='menu').props('flat color=white')
    # with ui.left_drawer(top_corner=True, bottom_corner=True).style('background-color: #d7e3f4'):
    #     ui.label('LEFT DRAWER')
    with ui.right_drawer(fixed=False).style('background-color: #ebf1fa').props('bordered') as right_drawer:
        ui.label('<Tasks>')

        for m in methods:
            fm = ui.checkbox(f'Draw heatmap ({m})', on_change=lambda e: update_pca_draw(e.value, viewer)).bind_value(app.storage.user, f'draw_{m}')
            with ui.grid(columns='60px 90px').classes('w-full').bind_visibility_from(fm, 'value'):
                ui.label('Opacity:')
                slider = ui.slider(min=0., max=1., value=0.5, step=0.1, on_change=lambda e: update_pca_draw(
                    e.value, viewer)).bind_value(app.storage.user, f'{m}_opacity')
    with ui.footer().style('background-color: #3874c8; height: 40px;').classes('items-center justify-between'):
        ui.label('ok.').bind_text_from(app.storage.user,'current_image_corner', backward=lambda c: f'Pos: x={c[0]}, y={c[1]}')



ui.run(
    host='0.0.0.0',
    port=8089,
    storage_secret='123',
    reload=True,
    )
