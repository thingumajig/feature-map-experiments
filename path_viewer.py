import io
import base64
import json

from pathlib import Path
from nicegui import app, ui
from fastapi import FastAPI, HTTPException, Response
from starlette.responses import StreamingResponse
from PIL import Image

from PIL import Image

from nicegui.events import MouseEventArguments


# Размер патча и количество патчей по горизонтали и вертикали
patch_size = 224

viewport_width = 1600
viewport_height = 600

# num_patches_x = width // patch_size
# num_patches_y = height // patch_size

# Функция для загрузки патча как SVG

class ImageData:
    def __init__(self, image_path: Path):
        self.image_path = image_path
        self.image = Image.open(image_path).convert('RGB')

        width, height = self.image.size
        print(f'{str(self.image_path)} size: {width}x{height}')

    def get_size(self):
        return self.image.size

    def toJSON(self):
        return json.dumps(
            self,
            default=lambda o: o.__dict__,
            sort_keys=True,
            indent=4)

def get_current_image():
    image_data = app.storage.client.get('image_data', None)
    if image_data is None:
        image_data = ImageData(Path(__file__).parent /
                               '.indexes' / 'c17-part1' / 'c17-part1.png')
        app.storage.client['image_data'] = image_data
        print(f'Load default image data...')
    return image_data

@app.get('/patch/{x}/{y}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_patch(x: int, y: int):
    try:
        image_data = get_current_image()
        # Вырезаем патч из большого изображения
        patch = image_data.image.crop((x, y, x + patch_size, y + patch_size))
        # Сохраняем патч в байтовом потоке
        buff = io.BytesIO()
        patch.save(buff, format='PNG')
        buff.seek(0)
        print(f'load original image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=600'}
                                 )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    

@app.get('/patch/pca/{x}/{y}',
         # Set what the media type will be in the autogenerated OpenAPI specification.
         # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
         responses={
             200: {
                 "content": {"image/png": {}}
             }
         },

         # Prevent FastAPI from adding "application/json" as an additional
         # response media type in the autogenerated OpenAPI specification.
         # https://github.com/tiangolo/fastapi/issues/3258
         response_class=Response
         )
async def get_patch_pca(x: int, y: int):
    try:
        image_data = get_current_image()
        pca_patch_path = image_data.image_path.parent / f'pca_{x}_{y}.png'
        # Вырезаем патч из большого изображения
        patch = Image.open(pca_patch_path).convert('RGB')
        # Сохраняем патч в байтовом потоке
        buff = io.BytesIO()
        patch.save(buff, format='PNG')
        buff.seek(0)
        print(f'load pca image: {x} {y}')
        return StreamingResponse(content=buff, media_type='image/png',
                                 headers={'Cache-Control': 'max-age=600'}
                                 )
    except Exception as e:
        print(f'File "pca_{x}_{y}" not found?')
        raise HTTPException(status_code=400, detail=str(e))


def load_patch_svg(x, y, origin_x, origin_y):
    left = x
    top = y

    # right = left + patch_size
    # bottom = top + patch_size
    # patch = large_image.crop((left, top, right, bottom))
    # patch_bytes = io.BytesIO()
    # patch.save(patch_bytes, format='PNG')
    # patch_bytes = patch_bytes.getvalue()
    # data_uri = 'data:image/png;base64,' + \
    #     base64.b64encode(patch_bytes).decode('utf-8')

    data_uri = f'/patch/{x}/{y}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{left-origin_x}" y="{top-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" />'


def load_pca_patch_svg(x, y, origin_x, origin_y):
    left = x
    top = y

    # right = left + patch_size
    # bottom = top + patch_size
    # patch = large_image.crop((left, top, right, bottom))
    # patch_bytes = io.BytesIO()
    # patch.save(patch_bytes, format='PNG')
    # patch_bytes = patch_bytes.getvalue()
    # data_uri = 'data:image/png;base64,' + \
    #     base64.b64encode(patch_bytes).decode('utf-8')

    data_uri = f'/patch/pca/{x}/{y}'

    # print(f'image: {left} {top} {right} {bottom}')
    return f'<image x="{left-origin_x}" y="{top-origin_y}" width="{patch_size}" height="{patch_size}" xlink:href="{data_uri}" opacity="0.5"/>'

def get_svg(x1: int, y1: int, x2: int, y2: int):
    # print(f'get svg: {x1=} {y1=} {x2=} {y2=}')
    pca_flag = app.storage.user.get('pca_draw', False)

    gridx = int(x1 // patch_size) * patch_size
    gridy = int(y1 // patch_size) * patch_size

    deltax = x1 - gridx
    deltay = y1 - gridy
    # print(f'{gridx=} {gridy=} {deltax=} {deltay=}')

    svg = f'<svg width="{viewport_width}px" height="{viewport_height}px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">'
    # for y in range(y1, y2 + 1, patch_size):
    #     for x in range(x1, x2 + 1, patch_size):
    #         svg += load_patch_svg(x, y, x1, y1)
    for y in range(gridy, y2 + 1, patch_size):
        for x in range(gridx, x2 + 1, patch_size):
            svg += load_patch_svg(x, y, x1, y1)
            if pca_flag:
                svg += load_pca_patch_svg(x, y, x1, y1)

    svg += '</svg>'
    return svg

    
def get_user_view_state():
    return (
        app.storage.user.get('mouse_down', False),
        app.storage.user.get('pan_start', (0, 0)),
        app.storage.user.get('current_image_corner', (0, 0)),
    )


def update_user_view_state(mouse_down=True, pan_start=None, current_image_corner=None):
    app.storage.user['mouse_down'] = mouse_down
    if pan_start:
        app.storage.user['pan_start'] = pan_start
    if current_image_corner:
        app.storage.user['current_image_corner'] = current_image_corner


def mouse_handler(e: MouseEventArguments):
    image_data = get_current_image()
    width, height = image_data.image.size

    if e.type == 'mousedown':
        update_user_view_state(
            mouse_down=True, pan_start=(e.image_x, e.image_y))
    elif (app.storage.user['mouse_down'] and e.type == 'mousemove') or e.type == 'mouseup':
        # print(f"event: {e.type} {app.storage.user['mouse_down']}")
        pan_start = app.storage.user['pan_start']

        delta_x = int(e.image_x - pan_start[0])
        delta_y = int(e.image_y - pan_start[1])

        x, y = app.storage.user.get('current_image_corner', (0, 0))

        x = max(x-delta_x, 0)
        y = max(y-delta_y, 0)

        x = min(x, width-viewport_width)
        y = min(y, height-viewport_height)

        # print(f'{e.type}: {delta_x=} {delta_y=} {x=} {y=}')
        update_user_view_state(mouse_down=(e.type == 'mousemove'), pan_start=(
            e.image_x, e.image_y), current_image_corner=(x, y))
        e.sender.set_content(
            get_svg(x, y, x+viewport_width, y+viewport_height))
    elif e.type == 'mouseleave':
        update_user_view_state(mouse_down=False)


def update_pca_draw(flag: bool, viewer):
    x, y = app.storage.user.get('current_image_corner', (0, 0))
    viewer.set_content(get_svg(x, y, x+viewport_width, y+viewport_height))





@ui.page('/')
def main_page():
    
    app.storage.client['image_data'] = None
    
    ui.add_head_html('''
        <style>
        body {
            overflow:hidden;
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        body::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        </style>
    ''')
    # with ui.card().tight() as container:
    with ui.row().classes('w-full h-full no-wrap') as container:

        # Устанавливаем стили для контейнера, чтобы он занимал всё доступное пространство
        # container.style(
        #     'display: flex; flex-direction: column; width: 100%; height: 80%;  overflow: hidden;')

        # ui.label('Viewer')
        # Создание интерфейса
        # Инициализация пустого SVG
        update_user_view_state(mouse_down=False, current_image_corner=(0, 0))
        viewer = ui.interactive_image(
            content=get_svg(0, 0, viewport_width, viewport_height), size=(viewport_width, viewport_width),
            on_mouse=mouse_handler, events=[
                'mousedown', 'mousemove', 'mouseup', 'mouseleave'],
            cross=True
        ).classes('w-full h-full')
        # .classes('w-64 bg-blue-50')
        # .style('width: 100%; height: 100%; object-fit: cover;')


    with ui.header(elevated=True).style('background-color: #3874c8').classes('items-center justify-between'):
        ui.label('RoseAId Unsupervised Semantic Segmentation')
        ui.button(on_click=lambda: right_drawer.toggle(),
                  icon='menu').props('flat color=white')
    # with ui.left_drawer(top_corner=True, bottom_corner=True).style('background-color: #d7e3f4'):
    #     ui.label('LEFT DRAWER')
    with ui.right_drawer(fixed=False).style('background-color: #ebf1fa').props('bordered') as right_drawer:
        ui.label('<Tasks>')
        ui.checkbox('Draw features heatmap', on_change=lambda e: update_pca_draw(e.value, viewer)).bind_value(app.storage.user, 'draw_pca')
    with ui.footer().style('background-color: #3874c8; height: 30px').classes('items-center justify-between'):
        ui.label('ok.')



# Запуск приложения
ui.run(
    host='0.0.0.0',
    port=8089,
    storage_secret='123',
    reload=True,
    )
